/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./example/src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./example/src/index.js":
/*!******************************!*\
  !*** ./example/src/index.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _constant = __webpack_require__(/*! sukkula/src/constant */ \"./src/constant.js\");\n\nvar _utility = __webpack_require__(/*! sukkula/src/utility */ \"./src/utility.js\");\n\nvar _source = __webpack_require__(/*! sukkula/src/source */ \"./src/source.js\");\n\nvar _sink = __webpack_require__(/*! sukkula/src/sink */ \"./src/sink.js\");\n\nvar _operator = __webpack_require__(/*! sukkula/src/operator */ \"./src/operator.js\");\n\nvar _wobble = __webpack_require__(/*! wobble */ \"./node_modules/.1.5.0@wobble/dist/wobble.es.js\");\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar springOptions = {\n  fromValue: 1,\n  toValue: 0,\n  stiffness: 1000,\n  damping: 20,\n  mass: 3\n};\n\nvar spring = function spring(options) {\n  return function (sink) {\n    var instance = new _wobble.Spring(_objectSpread({}, springOptions, options));\n    var callback = guard(function (type, payload) {\n      if (type === _constant.START) {\n        instance.start();\n        instance.onUpdate(function (data) {\n          return sink(_constant.NEXT, data);\n        });\n        instance.onStop(function () {\n          return callback(_constant.FINISH);\n        });\n        sink(_constant.START);\n      } else if (type === _constant.NEXT) {\n        sink(_constant.ASYNC);\n      } else if (type === _constant.FINISH) {\n        instance.stop();\n        sink(_constant.FINISH);\n      } else {\n        sink(type, payload);\n      }\n    });\n    return callback;\n  };\n};\n\nvar getEvent = function getEvent(event) {\n  return event.touches ? event.touches[0] : event;\n};\n\nvar getCoords = function getCoords(downEvent) {\n  var startX = downEvent.clientX;\n  var startY = downEvent.clientY;\n  return function (moveEvent) {\n    moveEvent.preventDefault();\n    downEvent = getEvent(downEvent);\n    moveEvent = getEvent(moveEvent);\n    return {\n      left: moveEvent.clientX - startX,\n      top: moveEvent.clientY - startY\n    };\n  };\n};\n\nvar setTranslate = function setTranslate(elem, _ref) {\n  var left = _ref.left,\n      top = _ref.top;\n  var translate = \"translate(\".concat(left, \"px, \").concat(top, \"px)\");\n  elem.style.transform = translate;\n  elem.style.webkitTransform = translate;\n};\n\nfunction drag() {\n  var _fromAction, _fromAction2, _fromAction3, _ref2, _start$, _merge, _start$2, _end$, _combineObject;\n\n  var action = {\n    START: Symbol('start'),\n    MOVE: Symbol('move'),\n    END: Symbol('end')\n  };\n  var start$ = (_fromAction = (0, _source.fromAction)(action.START), (0, _utility.logValue)('start')(_fromAction));\n  var move$ = (_fromAction2 = (0, _source.fromAction)(action.MOVE), (0, _utility.logValue)('move')(_fromAction2));\n  var end$ = (_fromAction3 = (0, _source.fromAction)(action.END), (0, _utility.logValue)('end')(_fromAction3));\n  var position$ = (_ref2 = (_start$ = start$, (0, _operator.switchMap)(function (downEvent) {\n    var _ref3, _move$;\n\n    return _ref3 = (_move$ = move$, (0, _operator.takeUntil)(end$)(_move$)), (0, _operator.map)(getCoords(downEvent))(_ref3);\n  })(_start$)), (0, _operator.startWith)({\n    left: 0,\n    top: 0\n  })(_ref2));\n  var status$ = (_merge = (0, _operator.merge)((_start$2 = start$, (0, _operator.mapTo)(true)(_start$2)), (_end$ = end$, (0, _operator.mapTo)(false)(_end$))), (0, _operator.startWith)(false)(_merge));\n  var data$ = (_combineObject = (0, _operator.combineObject)({\n    position: position$,\n    status: status$\n  }), (0, _operator.map)(function (data) {\n    if (data.status) {\n      return data.position;\n    } else {\n      return {\n        left: 0,\n        top: 0\n      };\n    }\n  })(_combineObject));\n  return {\n    data$: data$,\n    action: action\n  };\n}\n\nfunction dragBall(elem) {\n  var _ref4, _data$;\n\n  var _drag = drag(),\n      data$ = _drag.data$,\n      action = _drag.action;\n\n  var callback = (_ref4 = (_data$ = data$, (0, _sink.onNext)(function (data) {\n    console.log('data', data);\n    setTranslate(elem, data);\n  })(_data$)), (0, _sink.start)(_ref4));\n  elem.addEventListener('mousedown', function (event) {\n    callback(action.START, event);\n  });\n  document.addEventListener('mousemove', function (event) {\n    return callback(action.MOVE, event);\n  });\n  document.addEventListener('mouseup', function (event) {\n    return callback(action.END, event);\n  });\n}\n\ndragBall(document.querySelector('.ball'));\n\n//# sourceURL=webpack:///./example/src/index.js?");

/***/ }),

/***/ "./node_modules/.1.5.0@wobble/dist/wobble.es.js":
/*!******************************************************!*\
  !*** ./node_modules/.1.5.0@wobble/dist/wobble.es.js ***!
  \******************************************************/
/*! exports provided: Spring */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Spring\", function() { return Spring; });\nvar __assign=Object.assign||function(t){for(var i,e=1,n=arguments.length;e<n;e++){i=arguments[e];for(var r in i)Object.prototype.hasOwnProperty.call(i,r)&&(t[r]=i[r])}return t};function invariant(t,i){if(!t)throw new Error(i)}function withDefault(t,i){return void 0!==t&&null!==t?t:i}var Spring=function(){function t(t){void 0===t&&(t={}),this._listeners=[],this._currentAnimationStep=0,this._currentTime=0,this._springTime=0,this._currentValue=0,this._currentVelocity=0,this._isAnimating=!1,this._oscillationVelocityPairs=[],this._config={fromValue:withDefault(t.fromValue,0),toValue:withDefault(t.toValue,1),stiffness:withDefault(t.stiffness,100),damping:withDefault(t.damping,10),mass:withDefault(t.mass,1),initialVelocity:withDefault(t.initialVelocity,0),overshootClamping:withDefault(t.overshootClamping,!1),allowsOverdamping:withDefault(t.allowsOverdamping,!1),restVelocityThreshold:withDefault(t.restVelocityThreshold,.001),restDisplacementThreshold:withDefault(t.restDisplacementThreshold,.001)},this._currentValue=this._config.fromValue,this._currentVelocity=this._config.initialVelocity}return t.prototype.start=function(){var t=this,i=this._config,e=i.fromValue,n=i.toValue,r=i.initialVelocity;return e===n&&0===r||(this._reset(),this._isAnimating=!0,this._currentAnimationStep||(this._notifyListeners(\"onStart\"),this._currentAnimationStep=requestAnimationFrame(function(i){t._step(Date.now())}))),this},t.prototype.stop=function(){return this._isAnimating?(this._isAnimating=!1,this._notifyListeners(\"onStop\"),this._currentAnimationStep&&(cancelAnimationFrame(this._currentAnimationStep),this._currentAnimationStep=0),this):this},Object.defineProperty(t.prototype,\"currentValue\",{get:function(){return this._currentValue},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,\"currentVelocity\",{get:function(){return this._currentVelocity},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,\"isAtRest\",{get:function(){return this._isSpringAtRest()},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,\"isAnimating\",{get:function(){return this._isAnimating},enumerable:!0,configurable:!0}),t.prototype.updateConfig=function(t){this._advanceSpringToTime(Date.now());var i={fromValue:this._currentValue,initialVelocity:this._currentVelocity};return this._config=__assign({},this._config,i,t),this._reset(),this},t.prototype.onStart=function(t){return this._listeners.push({onStart:t}),this},t.prototype.onUpdate=function(t){return this._listeners.push({onUpdate:t}),this},t.prototype.onStop=function(t){return this._listeners.push({onStop:t}),this},t.prototype.removeListener=function(t){return this._listeners=this._listeners.reduce(function(i,e){return-1!==Object.values(e).indexOf(t)||i.push(e),i},[]),this},t.prototype.removeAllListeners=function(){return this._listeners=[],this},t.prototype._reset=function(){this._currentTime=Date.now(),this._springTime=0,this._currentValue=this._config.fromValue,this._currentVelocity=this._config.initialVelocity},t.prototype._notifyListeners=function(t){var i=this;this._listeners.forEach(function(e){var n=e[t];\"function\"==typeof n&&n(i)})},t.prototype._step=function(t){var i=this;this._advanceSpringToTime(t,!0),this._isAnimating&&(this._currentAnimationStep=requestAnimationFrame(function(t){return i._step(Date.now())}))},t.prototype._advanceSpringToTime=function(i,e){if(void 0===e&&(e=!1),this._isAnimating){var n=i-this._currentTime;n>t.MAX_DELTA_TIME_MS&&(n=t.MAX_DELTA_TIME_MS),this._springTime+=n;var r=this._config.damping,s=this._config.mass,o=this._config.stiffness,a=this._config.fromValue,h=this._config.toValue,u=-this._config.initialVelocity;invariant(s>0,\"Mass value must be greater than 0\"),invariant(o>0,\"Stiffness value must be greater than 0\"),invariant(r>0,\"Damping value must be greater than 0\");var c=r/(2*Math.sqrt(o*s)),l=Math.sqrt(o/s)/1e3,f=l*Math.sqrt(1-c*c),p=l*Math.sqrt(c*c-1),_=h-a;c>1&&!this._config.allowsOverdamping&&(c=1);var g=0,m=0,y=this._springTime;if(c<1)g=h-(V=Math.exp(-c*l*y))*((u+c*l*_)/f*Math.sin(f*y)+_*Math.cos(f*y)),m=c*l*V*(Math.sin(f*y)*(u+c*l*_)/f+_*Math.cos(f*y))-V*(Math.cos(f*y)*(u+c*l*_)-f*_*Math.sin(f*y));else if(1===c){g=h-(V=Math.exp(-l*y))*(_+(u+l*_)*y),m=V*(u*(y*l-1)+y*_*(l*l))}else{var V;g=h-(V=Math.exp(-c*l*y))*((u+c*l*_)*Math.sinh(p*y)+p*_*Math.cosh(p*y))/p,m=V*c*l*(Math.sinh(p*y)*(u+c*l*_)+_*p*Math.cosh(p*y))/p-V*(p*Math.cosh(p*y)*(u+c*l*_)+p*p*_*Math.sinh(p*y))/p}if(this._currentTime=i,this._currentValue=g,this._currentVelocity=m,e&&(this._notifyListeners(\"onUpdate\"),this._isAnimating))return this._isSpringOvershooting()||this._isSpringAtRest()?(0!==o&&(this._currentValue=h,this._currentVelocity=0,this._notifyListeners(\"onUpdate\")),void this.stop()):void 0}},t.prototype._isSpringOvershooting=function(){var t=this._config,i=t.stiffness,e=t.fromValue,n=t.toValue,r=!1;return t.overshootClamping&&0!==i&&(r=e<n?this._currentValue>n:this._currentValue<n),r},t.prototype._isSpringAtRest=function(){var t=this._config,i=t.stiffness,e=t.toValue,n=t.restDisplacementThreshold,r=t.restVelocityThreshold,s=Math.abs(this._currentVelocity)<=r;return 0!==i&&Math.abs(e-this._currentValue)<=n&&s},t.MAX_DELTA_TIME_MS=1/60*1e3*4,t}();\n//# sourceMappingURL=wobble.es.js.map\n\n\n//# sourceURL=webpack:///./node_modules/.1.5.0@wobble/dist/wobble.es.js?");

/***/ }),

/***/ "./src/constant.js":
/*!*************************!*\
  !*** ./src/constant.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ERROR = exports.ASYNC = exports.FINISH = exports.NEXT = exports.START = void 0;\nvar START = 0;\nexports.START = START;\nvar NEXT = 1;\nexports.NEXT = NEXT;\nvar FINISH = 2;\nexports.FINISH = FINISH;\nvar ASYNC = 3;\nexports.ASYNC = ASYNC;\nvar ERROR = 4;\nexports.ERROR = ERROR;\n\n//# sourceURL=webpack:///./src/constant.js?");

/***/ }),

/***/ "./src/operator.js":
/*!*************************!*\
  !*** ./src/operator.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.startWith = exports.switchMap = exports.takeUntil = exports.share = exports.concat = exports.combineObject = exports.combine = exports.merge = exports.take = exports.filter = exports.mapTo = exports.map = void 0;\n\nvar _constant = __webpack_require__(/*! ./constant */ \"./src/constant.js\");\n\nvar _utility = __webpack_require__(/*! ./utility */ \"./src/utility.js\");\n\nvar _source4 = __webpack_require__(/*! ./source */ \"./src/source.js\");\n\nvar _sink = __webpack_require__(/*! ./sink */ \"./src/sink.js\");\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nvar map = function map(f) {\n  return function (source) {\n    return function (sink) {\n      return source(function (type, payload) {\n        sink(type, type === _constant.NEXT ? f(payload) : payload);\n      });\n    };\n  };\n};\n\nexports.map = map;\n\nvar mapTo = function mapTo(value) {\n  return map(function () {\n    return value;\n  });\n};\n\nexports.mapTo = mapTo;\n\nvar filter = function filter(f) {\n  return function (source) {\n    return function (sink) {\n      var callback = source(function (type, payload) {\n        if (type === _constant.NEXT) {\n          if (f(payload)) {\n            sink(_constant.NEXT, payload);\n          } else {\n            callback(_constant.NEXT);\n          }\n        } else {\n          sink(type, payload);\n        }\n      });\n      return callback;\n    };\n  };\n};\n\nexports.filter = filter;\n\nvar take = function take(max) {\n  return function (source) {\n    return function (sink) {\n      var count = 0;\n      var callback = source(function (type, payload) {\n        if (type === _constant.NEXT) {\n          if (count < max) {\n            count += 1;\n            sink(_constant.NEXT, payload);\n\n            if (count === max) {\n              callback(_constant.FINISH);\n            }\n          }\n        } else if (type === _constant.FINISH) {\n          sink(_constant.FINISH);\n        } else {\n          sink(type, payload);\n        }\n      });\n      return callback;\n    };\n  };\n};\n\nexports.take = take;\n\nvar merge = function merge() {\n  for (var _len = arguments.length, sourceList = new Array(_len), _key = 0; _key < _len; _key++) {\n    sourceList[_key] = arguments[_key];\n  }\n\n  return function (sink) {\n    var callbackList;\n    var finishCount = 0;\n\n    var next = function next(payload) {\n      return sink(_constant.NEXT, payload);\n    };\n\n    var finish = function finish() {\n      return ++finishCount === sourceList.length && callback(_constant.FINISH);\n    };\n\n    var callback = (0, _utility.guard)(function (type, payload) {\n      if (type === _constant.START) {\n        callbackList = sourceList.map(function (source) {\n          var _ref, _ref2, _source;\n\n          return _ref = (_ref2 = (_source = source, (0, _sink.onNext)(next)(_source)), (0, _sink.onFinish)(finish)(_ref2)), (0, _sink.start)(_ref);\n        });\n        sink(_constant.START);\n      } else if (type === _constant.NEXT) {\n        sink(_constant.ASYNC);\n      } else if (type === _constant.FINISH) {\n        callbackList.forEach(function (callback) {\n          return callback(_constant.FINISH);\n        });\n        sink(_constant.FINISH);\n      } else {\n        sink(type, payload);\n      }\n    });\n    return callback;\n  };\n};\n\nexports.merge = merge;\nvar EMPTY = {};\n\nvar combine = function combine() {\n  for (var _len2 = arguments.length, sourceList = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    sourceList[_key2] = arguments[_key2];\n  }\n\n  return function (sink) {\n    var finishCount = 0;\n\n    var finish = function finish() {\n      return ++finishCount === sourceList.length && callback(_constant.FINISH);\n    };\n\n    var valueList = [];\n\n    var next = function next(payload, index) {\n      valueList[index] = payload;\n\n      if (valueList.indexOf(EMPTY) === -1) {\n        sink(_constant.NEXT, valueList.concat());\n      }\n    };\n\n    var callbackList = sourceList.map(function (source, index) {\n      var _ref3, _ref4, _source2;\n\n      valueList[index] = EMPTY;\n      return _ref3 = (_ref4 = (_source2 = source, (0, _sink.onNext)(function (payload) {\n        return next(payload, index);\n      })(_source2)), (0, _sink.onFinish)(finish)(_ref4)), (0, _sink.toCallback)(_ref3);\n    });\n    var callback = (0, _utility.guard)(function (type, payload) {\n      if (type === _constant.START) {\n        callbackList.forEach(function (callback) {\n          return callback(_constant.START);\n        });\n        sink(_constant.START);\n      } else if (type === _constant.NEXT) {\n        sink(_constant.ASYNC);\n      } else if (type === _constant.FINISH) {\n        callbackList.forEach(function (callback) {\n          return callback(_constant.FINISH);\n        });\n        sink(_constant.FINISH);\n      } else {\n        sink(type, payload);\n      }\n    });\n    return callback;\n  };\n};\n\nexports.combine = combine;\n\nvar combineObject = function combineObject(shape) {\n  var _combine;\n\n  var keys = Object.keys(shape);\n  var sourceList = keys.map(function (key) {\n    return shape[key];\n  });\n  return _combine = combine.apply(void 0, _toConsumableArray(sourceList)), map(function (valueList) {\n    return valueList.reduce(function (result, value, index) {\n      result[keys[index]] = value;\n      return result;\n    }, {});\n  })(_combine);\n};\n\nexports.combineObject = combineObject;\n\nvar concat = function concat() {\n  for (var _len3 = arguments.length, sourceList = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    sourceList[_key3] = arguments[_key3];\n  }\n\n  return function (sink) {\n    var index = 0;\n    var loopCallback = null;\n    var isStarted = false;\n\n    var loop = function loop() {\n      if (index === sourceList.length) {\n        if (index === 0) sink(_constant.START);\n        callback(_constant.FINISH);\n        return;\n      }\n\n      loopCallback = sourceList[index++](function (type, payload) {\n        if (type === _constant.START) {\n          if (!isStarted) {\n            isStarted = true;\n            sink(_constant.START);\n          } else {\n            loopCallback(_constant.NEXT);\n          }\n        } else if (type === _constant.NEXT) {\n          sink(_constant.NEXT, payload);\n        } else if (type === _constant.FINISH) {\n          loop();\n        } else {\n          sink(type, payload);\n        }\n      });\n      loopCallback(_constant.START);\n    };\n\n    var callback = (0, _utility.guard)(function (type, payload) {\n      if (type === _constant.START) {\n        loop();\n      } else if (type === _constant.FINISH) {\n        loopCallback && loopCallback(_constant.FINISH);\n        sink(_constant.FINISH);\n      } else {\n        loopCallback && loopCallback(type, payload);\n      }\n    });\n    return callback;\n  };\n};\n\nexports.concat = concat;\n\nvar share = function share(source) {\n  var _ref5, _source3;\n\n  var list = [];\n  var isStarted = false;\n  var isFinished = false;\n  var observer = {\n    start: function start() {\n      isStarted = true;\n      var sinkList = list.concat();\n\n      for (var i = 0; i < sinkList.length; i++) {\n        sinkList[i](_constant.START);\n      }\n    },\n    next: function next(payload) {\n      var sinkList = list.concat();\n\n      for (var i = 0; i < sinkList.length; i++) {\n        sinkList[i](_constant.NEXT, payload);\n      }\n    },\n    finish: function finish() {\n      isFinished = true;\n      var sinkList = list.concat();\n\n      for (var i = 0; i < sinkList.length; i++) {\n        sinkList[i](_constant.FINISH);\n      }\n    }\n  };\n  var realCallback = (_ref5 = (_source3 = source, (0, _sink.observe)(observer)(_source3)), (0, _sink.toCallback)(_ref5));\n  return function (sink) {\n    var callback = (0, _utility.guard)(function (type, payload) {\n      if (type === _constant.START) {\n        if (!isStarted) {\n          realCallback(_constant.START);\n        } else {\n          sink(_constant.START);\n        }\n      } else if (type === _constant.NEXT) {\n        if (isFinished) {\n          sink(_constant.FINISH);\n        } else {\n          sink(_constant.ASYNC);\n        }\n      } else if (type === _constant.FINISH) {\n        var index = list.indexOf(sink);\n\n        if (index !== -1) {\n          list.splice(index, 1);\n        }\n\n        sink(_constant.FINISH);\n\n        if (list.length === 0) {\n          realCallback(_constant.FINISH);\n        }\n      } else {\n        realCallback(type, payload);\n      }\n    });\n    list.push(sink);\n    return callback;\n  };\n};\n\nexports.share = share;\n\nvar takeUntil = function takeUntil(until$) {\n  return function (source) {\n    return function (sink) {\n      var innerCallback = null;\n      var callback = source(function (type, payload) {\n        if (type === _constant.START) {\n          var _ref6, _until$;\n\n          innerCallback = (_ref6 = (_until$ = until$, (0, _sink.onNext)(function () {\n            return callback(_constant.FINISH);\n          })(_until$)), (0, _sink.toCallback)(_ref6));\n          innerCallback(_constant.START);\n          sink(_constant.START);\n        } else if (type === _constant.FINISH) {\n          innerCallback(_constant.FINISH);\n          sink(_constant.FINISH);\n        } else {\n          sink(type, payload);\n        }\n      });\n      return callback;\n    };\n  };\n};\n\nexports.takeUntil = takeUntil;\n\nvar switchMap = function switchMap(makeSource) {\n  return function (source) {\n    return function (sink) {\n      var innerCallback = null;\n      var outerFinished = false;\n      var innerFinished = false;\n\n      var next = function next(payload) {\n        return sink(_constant.NEXT, payload);\n      };\n\n      var finish = function finish() {\n        innerCallback = null;\n        innerFinished = true;\n\n        if (outerFinished) {\n          callback(_constant.FINISH);\n        } else {\n          outerCallback(_constant.NEXT);\n        }\n      };\n\n      var outerCallback = source(function (type, payload) {\n        if (type === _constant.NEXT) {\n          var _ref7, _ref8, _makeSource;\n\n          innerCallback && innerCallback(_constant.FINISH);\n          innerCallback = (_ref7 = (_ref8 = (_makeSource = makeSource(payload), (0, _sink.onNext)(next)(_makeSource)), (0, _sink.onFinish)(finish)(_ref8)), (0, _sink.toCallback)(_ref7));\n          innerFinished = false;\n          innerCallback(_constant.START);\n        } else if (type === _constant.FINISH) {\n          outerFinished = true;\n\n          if (innerFinished) {\n            callback(_constant.FINISH);\n          }\n        } else {\n          sink(type, payload);\n        }\n      });\n      var callback = (0, _utility.guard)(function (type, payload) {\n        if (type === _constant.NEXT) {\n          if (innerCallback) {\n            innerCallback(_constant.NEXT);\n          } else {\n            outerCallback(_constant.NEXT);\n          }\n        } else if (type === _constant.FINISH) {\n          innerCallback && innerCallback(_constant.FINISH);\n          outerCallback(_constant.FINISH);\n          sink(_constant.FINISH);\n        } else {\n          outerCallback(type, payload);\n        }\n      });\n      return callback;\n    };\n  };\n};\n\nexports.switchMap = switchMap;\n\nvar startWith = function startWith(startValue) {\n  return function (source) {\n    return function (sink) {\n      var sent = false;\n      var callback = source(sink);\n      return (0, _utility.guard)(function (type, payload) {\n        if (type === _constant.NEXT) {\n          if (!sent) {\n            sent = true;\n            sink(_constant.NEXT, startValue);\n          } else {\n            callback(type, payload);\n          }\n        } else {\n          callback(type, payload);\n        }\n      });\n    };\n  };\n};\n\nexports.startWith = startWith;\n\n//# sourceURL=webpack:///./src/operator.js?");

/***/ }),

/***/ "./src/sink.js":
/*!*********************!*\
  !*** ./src/sink.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.start = exports.toCallback = exports.observe = exports.onError = exports.onAsync = exports.onFinish = exports.onNext = exports.onStart = exports.onType = void 0;\n\nvar _constant = __webpack_require__(/*! ./constant */ \"./src/constant.js\");\n\nvar _utility = __webpack_require__(/*! ./utility */ \"./src/utility.js\");\n\nvar onType = function onType(theType) {\n  return function (handler) {\n    return function (source) {\n      return function (sink) {\n        var callback = source(function (type, payload) {\n          if (type === theType) {\n            handler && handler(payload, callback);\n          }\n\n          sink(type, payload);\n        });\n        return callback;\n      };\n    };\n  };\n};\n\nexports.onType = onType;\nvar onStart = onType(_constant.START);\nexports.onStart = onStart;\nvar onNext = onType(_constant.NEXT);\nexports.onNext = onNext;\nvar onFinish = onType(_constant.FINISH);\nexports.onFinish = onFinish;\nvar onAsync = onType(_constant.ASYNC);\nexports.onAsync = onAsync;\nvar onError = onType(_constant.ERROR);\nexports.onError = onError;\n\nvar observe = function observe(_ref) {\n  var start = _ref.start,\n      next = _ref.next,\n      finish = _ref.finish,\n      async = _ref.async,\n      error = _ref.error;\n  return function (source) {\n    var _ref2, _ref3, _ref4, _ref5, _source;\n\n    return _ref2 = (_ref3 = (_ref4 = (_ref5 = (_source = source, onStart(start)(_source)), onNext(next)(_ref5)), onFinish(finish)(_ref4)), onAsync(async)(_ref3)), onError(error)(_ref2);\n  };\n};\n\nexports.observe = observe;\n\nvar toCallback = function toCallback(source) {\n  var callback = source(function (type, payload) {\n    if (type === _constant.START) {\n      callback(_constant.NEXT);\n    } else if (type === _constant.NEXT) {\n      callback(_constant.NEXT);\n    }\n  });\n  return callback;\n};\n\nexports.toCallback = toCallback;\n\nvar start = function start(source) {\n  var callback = toCallback(source);\n  callback(_constant.START);\n  return callback;\n};\n\nexports.start = start;\n\n//# sourceURL=webpack:///./src/sink.js?");

/***/ }),

/***/ "./src/source.js":
/*!***********************!*\
  !*** ./src/source.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fromAction = exports.fromRange = exports.fromArray = exports.interval = void 0;\n\nvar _constant = __webpack_require__(/*! ./constant */ \"./src/constant.js\");\n\nvar _utility = __webpack_require__(/*! ./utility */ \"./src/utility.js\");\n\nvar interval = function interval(period) {\n  return function (sink) {\n    var timer;\n    var i = 0;\n    return (0, _utility.guard)(function (type, payload) {\n      if (type === _constant.START) {\n        timer = setInterval(function () {\n          return sink(_constant.NEXT, i++);\n        }, period);\n        sink(_constant.START);\n      } else if (type === _constant.FINISH) {\n        clearInterval(timer);\n        sink(_constant.FINISH);\n      } else if (type === _constant.NEXT) {\n        sink(_constant.ASYNC);\n      } else {\n        sink(type, payload);\n      }\n    });\n  };\n};\n\nexports.interval = interval;\n\nvar fromArray = function fromArray(array) {\n  return function (sink) {\n    var i = 0;\n    var callback = (0, _utility.guard)(function (type, payload) {\n      if (type === _constant.NEXT) {\n        if (i < array.length) {\n          sink(_constant.NEXT, array[i++]);\n\n          if (i === array.length) {\n            callback(_constant.FINISH);\n          }\n        }\n      } else if (type === _constant.FINISH) {\n        sink(_constant.FINISH);\n      } else {\n        sink(type, payload);\n      }\n    });\n    return callback;\n  };\n};\n\nexports.fromArray = fromArray;\n\nvar fromRange = function fromRange() {\n  var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  return function (sink) {\n    var isGT = end > start;\n    var sent = start - step;\n    var callback = (0, _utility.guard)(function (type, payload) {\n      if (type === _constant.START) {\n        sink(_constant.START);\n      } else if (type === _constant.NEXT) {\n        if (start === end) {\n          callback(_constant.FINISH);\n        } else {\n          sent += step;\n\n          if (isGT ? sent <= end : sent >= end) {\n            sink(_constant.NEXT, sent);\n\n            if (isGT ? sent > end : sent < end) {\n              callback(_constant.FINISH);\n            }\n          } else if (isGT ? sent > end : sent < end) {\n            callback(_constant.FINISH);\n          }\n        }\n      } else {\n        sink(type, payload);\n      }\n    });\n    return callback;\n  };\n};\n\nexports.fromRange = fromRange;\n\nvar fromAction = function fromAction(actionType) {\n  return function (sink) {\n    var callback = (0, _utility.guard)(function (type, payload) {\n      if (type === actionType) {\n        sink(_constant.NEXT, payload);\n      } else if (type === _constant.NEXT) {\n        sink(_constant.ASYNC);\n      } else {\n        sink(type, payload);\n      }\n    });\n    return callback;\n  };\n};\n\nexports.fromAction = fromAction;\n\n//# sourceURL=webpack:///./src/source.js?");

/***/ }),

/***/ "./src/utility.js":
/*!************************!*\
  !*** ./src/utility.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.logValue = exports.log = exports.guard = void 0;\n\nvar _constant = __webpack_require__(/*! ./constant */ \"./src/constant.js\");\n\nvar guard = function guard(callback) {\n  var isStarted = false;\n  var isFinished = false;\n\n  var guarder = function guarder(type, payload) {\n    if (!isStarted && type !== _constant.START) {\n      var message = \"source should be started before action: \".concat(type);\n      throw new Error(message);\n    }\n\n    if (isFinished) return;\n    if (isStarted && type === _constant.START) return;\n    if (type === _constant.START) isStarted = true;\n    if (type === _constant.FINISH) isFinished = true;\n    callback(type, payload);\n  };\n\n  guarder.original = callback;\n  return guarder;\n};\n\nexports.guard = guard;\nvar action = {\n  START: _constant.START,\n  NEXT: _constant.NEXT,\n  FINISH: _constant.FINISH,\n  ASYNC: _constant.ASYNC,\n  ERROR: _constant.ERROR\n};\n\nvar getActionName = function getActionName(type) {\n  var target = Object.keys(action).find(function (name) {\n    return action[name] === type;\n  });\n  return target != null ? target : type;\n};\n\nvar log = function log(name) {\n  return function (source) {\n    return function (sink) {\n      var callback = source(function (type, payload) {\n        console.log('[forward]', name, getActionName(type), payload);\n        return sink(type, payload);\n      });\n      return guard(function (type, payload) {\n        console.log('[backward]', name, getActionName(type), payload);\n        return callback(type, payload);\n      });\n    };\n  };\n};\n\nexports.log = log;\n\nvar logValue = function logValue(name) {\n  return function (source) {\n    return function (sink) {\n      return source(function (type, payload) {\n        if (type === _constant.NEXT) {\n          console.log('[value]', name, payload);\n        }\n\n        return sink(type, payload);\n      });\n    };\n  };\n};\n\nexports.logValue = logValue;\n\n//# sourceURL=webpack:///./src/utility.js?");

/***/ })

/******/ });